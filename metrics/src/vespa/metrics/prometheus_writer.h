// Copyright Vespa.ai. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
#pragma once

#include "metric.h"
#include <vespa/vespalib/stllike/hash_set.h>
#include <vespa/vespalib/util/small_vector.h>
#include <vespa/vespalib/util/stash.h>
#include <vespa/vespalib/util/time.h>
#include <variant>
#include <vector>

namespace vespalib { class asciistream; }

namespace metrics {

/**
 * Metric snapshot writer which emits text output conforming to the Prometheus
 * 0.0.4 exposition format.
 *
 * Metrics are emitted by effectively "flattening" all paths in the metric tree
 * and grouping by path and aggregation type (sum, count etc).
 *
 * - For CountMetrics, emits `_count` (i64) time series only.
 * - For ValueMetrics, emits `_count` (i64), `_sum`, `_min` and `_max` (double)
 *   time series (`_last` and `_average` are _not_ included).
 *
 * Due to poor compatibility between Prometheus and our internal data model, all
 * time series are emitted as "untyped".
 */
class PrometheusWriter : public MetricVisitor {
    using I64OrDouble = std::variant<int64_t, double>;
    struct TimeSeriesSample {
        // All referenced strings shall be either arena-allocated or static
        vespalib::ConstArrayRef<vespalib::stringref> metric_path;
        vespalib::stringref                          aggr;
        // Labels are laid out in key/value pairs, that is size() is always % 2 == 0
        vespalib::ConstArrayRef<vespalib::stringref> labels;
        I64OrDouble                                  value;

        bool operator<(const TimeSeriesSample& rhs) const noexcept;
    };

    vespalib::Stash                         _arena;
    std::string                             _timestamp_str;
    std::vector<TimeSeriesSample>           _samples;
    vespalib::hash_set<vespalib::stringref> _unique_str_refs;
    std::vector<vespalib::stringref>        _path;
    vespalib::asciistream&                  _out;
public:
    explicit PrometheusWriter(vespalib::asciistream& out);
    ~PrometheusWriter() override;

private:
    [[nodiscard]] vespalib::stringref arena_stable_string_ref(vespalib::stringref str);
    [[nodiscard]] vespalib::ConstArrayRef<vespalib::stringref> as_prometheus_labels(const Metric& m);
    [[nodiscard]] vespalib::ConstArrayRef<vespalib::stringref> metric_to_path_ref(vespalib::stringref leaf_metric_name);
    [[nodiscard]] vespalib::stringref stable_name_string_ref(vespalib::stringref raw_name);
    [[nodiscard]] vespalib::stringref stable_label_value_string_ref(vespalib::stringref raw_label_value);
    void build_labels_upto_root(vespalib::SmallVector<vespalib::stringref, 16>& out, const Metric& m);

    [[nodiscard]] static vespalib::string escaped_label_value(vespalib::stringref value);
    // Renders name with a tailing '_' character, as the caller is expected to append an aggregate.
    static void render_path_as_metric_name_prefix(vespalib::asciistream& out, vespalib::ConstArrayRef<vespalib::stringref> path);
    static void render_label_pairs(vespalib::asciistream& out, vespalib::ConstArrayRef<vespalib::stringref> labels);
    static void render_sample_value(vespalib::asciistream& out, I64OrDouble value);

    // MetricVisitor impl
    bool visitSnapshot(const MetricSnapshot&) override;
    void doneVisitingSnapshot(const MetricSnapshot&) override;
    bool visitMetricSet(const MetricSet&, bool autoGenerated) override;
    void doneVisitingMetricSet(const MetricSet&) override;
    bool visitCountMetric(const AbstractCountMetric&, bool autoGenerated) override;
    bool visitValueMetric(const AbstractValueMetric&, bool autoGenerated) override;
    void doneVisiting() override;
};

}
